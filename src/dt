#include "dt.hpp"

#include <thread>
#include <mutex>
#include <queue>

using namespace std;

mutex m;

void DT::fromDAG(const DAG &dag)
{
    vector<vector<unsigned long>> path;

    for (int i = 0; i < size; i++)
        parent.emplace_back(i);

    queue<unsigned long> Q;

    for (auto it = dag.get_np().begin(); it != dag.get_np().end(); it++)
        if (*it == 0)
            Q.push(*it);
    
    while (!Q.empty())
    {
        queue<unsigned long> C;
        vector<thread> thread_pool;

        while (!Q.empty())
        {
            unsigned long np = Q.front();
            Q.pop();
            thread_pool.emplace_back(thread(fp, np))
        }

        for (auto it = thread_pool.begin(); it != thread_pool.end(); it++)
            (*it).join();

        swap(Q, C);
    }
}

void fp(unsigned long np, const vector<unsigned long> &IA, const vector<unsigned long> &JA)
{
    for (unsigned long i = IA[np]; i < IA[np+1]; i++)
    {
        // task(path, JA[i], p)
    }
    // wait all tasks
    thread_exit();
}

void compute_path(unsigned long i, unsigned long p)
{
    vector<unsigned long> path, pri, qri;
    bool update;
    pri = path;
    pri.emplace_back(i);
    qri = path;

    update = (qri.empty() || cmppath(pri, qri) <= 0);

    m.lock();
    if (update)
    {
        parent[i] = p;
        path[i] = pri;
    }
    if (--np[i] == 0)
        P.push(i);

    m.unlock();
}

unsigned long cmppath(vector<unsigned long> a, vector<unsigned long> b)
{
    for (auto ita = a.begin(), itb = b.begin(); ita != a.end() && itb != b.end(); ita++, itb++)
    {
        if (*ita == *itb)
            continue;

        return *ita - *itb;
    }

    return 0;
}
// Initialize all sub-graph sizes to 0.
// Find leafs and insert them into queue Q.
// while Q != {} do
//   for node i in Q do in parallel
//       Let Pi be a set of parents of i and queue C = {}
//       for node p of Pi do in parallel
//           Mark p outgoing edge (p; i) as visited
//           Insert p into C if all outgoing edges are visited
//       end for
//   end for
//   for node p of C do in parallel
//       Let Cp be an ordered set of children of node p
//       Compute a prex-sum on Cp, obtaining cp
//       (use lexicographic ordering of elements in Cp)
//   end for
//   Set queue Q = C for the next iteration
// end while

// ////////////////////////////////////

BFS1_bottomup_subgraph_size () {
    sub_size[graph_size] = {1}; // Initialize all sub-graph sizes to 0 -> for us 1 avoid uselles computation
    Q = new List(); 
    vector to_be_marked[graph_size] // viene usato per contare quanti altri edges di ogni padre vanno visitati, è inizializzato con il numero di figli di ogni nodo


    for (int i = 0; i<graph_size; i++) {
        if (IA[i+1] - IA[i] == 0) // non ha figli -> è una foglia 
            Q.insert(i); // Find leafs and insert them into queue Q
        to_be_marked[i] = IA[i+1] - IA[i];
    } 

    while (! Q.isEmpty() )  { // while Q != {} do
        C = new List();
        for (each n_i in Q) // for node i in Q do in parallel
            thread_nodeQ(n_i);

        wait_for_all_thread(thread_nodeQ); 

        for (each n_p in C) // for node p of C do in parallel
            thread_nodeC(n_p); 
        
        wait_for_all_thread(thread_nodeC);
        Q = move(C) // Set queue Q = C for the next iteration
                    // su C bisogna poi fare la free()

    }
} 


thread_nodeQ(i) {
    Pi = P[n_i]; //Let Pi be a set of parents of i
    for (each p in Pi) // for node p of Pi do in parallel
        task(mark, p); 
    exit_thread();
}

mark (p) { 

    lock(to_be_marked);
    to_be_marked[p] -= 1; // Mark p outgoing edge (p; i) as visited
    if (to_be_marked[p] == 0)
        C.insert(p) // Insert p into C if all outgoing edges are visited
    unlock(to_be_marked); 

}

thread_nodeC(p) {
    int sub = 0;
    for (int i = IA[p]; i < IA[p+1]; i++) // Let Cp be an ordered set of children of node p
        sub += sub_size[i];   // Compute a prex-sum on Cp, obtaining cp

    sub_size[p] += sub; 
        
}